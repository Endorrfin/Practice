



// |+|+|+| === MODULE 4.2 THIS - КОНТЕКСТ ИСПОЛНЕНИЯ ===  |+|+|+|

/**
 * Во время вызова этого метода, this будет ссылаться на тот объект, который вызвал функцию!
 * Кто вызвал фукнцию, на тот объект this и ссылается во время ее вызова.
 * Ключевое слово this получает значение не во время объявления функции, а во время вызова.
 * this определяется не местом объявления, а местом вызова.
 * this есть в любых фукнциях, кроме стрелок.
 * 
 * Проблема, когда метод объекта передаем как callback, то у нее теряется контекст.
 */

// EXAMPLE I
// const product1 = {
//   label: 'Adidas',
//   showLabel () {
//     console.log(product1.label);
//   },
// };

// product1.showLabel(); // Adidas


// EXAMPLE II
const product2 = {
  label: 'Adidas',
  showLabel () {
    console.log(this); // {label: "Adidas", showLabel: ƒ}
    console.log(this.label); // Adidas
  },
};

product2.showLabel();








// *** 2019.11.28 |+|+|+|+|+|+|+|   Example#1   |+|+|+|+|+|+|+|

// const users = ['Mango', 'Ajax', 'Polu'];
// const login = prompt('Введите логин!');

// const isRegistered = usres.includes(login);

// if (isRegistered) {
//   console.log('Добро пожаловать!');
// } else {
//   console.log('Неверный пароль');
// }



// *** 2019.11.28 |+|+|+|+|+|+|+|   Example#2   |+|+|+|+|+|+|+|

// const matrix = [[1, 2, 3], [4, 5, 6] [7, 8, 9]];
// for (let i = 0; i < matrix.length; i += 1) {
// console.group(`Iteration ${i}`);
// console.log('i :', i);
// console.log(`matrix[${i}] :`, matrix[i]);

// for (let j = 0; j < matrix[i].length; j += 1) {
//   console.log('j :', j);
//   console.log(`matrix[${i}][${j}]:`, matrix[i][j]);
// }

// console.groupEnd(`Iteration ${i}`);
// }




// |+|+|+| === Lexical scoping #1 ===  |+|+|+|

// var a = 12;

// function f () {
//   var b = 3;

//   console.log(b); // будет каждый раз новая
//   console.log(a); // будет всегда одно и та же
// }

// f();
// f();
// f();


// // |+|+|+| === count #1 ===  |+|+|+|

// var count = 0;

// function counter () {
//   // функция counter будет влиять на переменную count
//   count++;

//   return count;
// }

// /* 
// При каждом вызове функции counter(), переменной count будет присваиваться новое значение.
// Нам важно, чтоб переменная count была в другой области видимости, поскольку, если бы она была в области видимости функции counter(), то при вызове counter() переменная count будет равна одному и тому же, а нам это не подходит!

// Нам необходимо, чтоб измененное состояние переменной count где-то сохранялось. Поэтому мы выносим переменную count в глобальную область видимости и обращаемся к ней из функции.

// А что, если задача создать несколько таких счетчиков?
// Нам каждый раз придется создавать глобальную переменную и функцию? Это не очень хорошо, поскольку мы стараемся в глобальной области видимости создавать поменьше переменных.
// */
// console.log(counter());
// console.log(counter());
// console.log(counter());




// |+|+|+| === closure #1 ===  |+|+|+|

// function Counter() {
//   var count = 0;

//   return function() {
//     count++;

//     return count;
//   }
// }

// /* 
// Создаем функцию Counter, которая внути себя объявляет переменную count и возвращает новую функцию.
// Вот эта новая функция, которая возвращается из Counter, про нее говорят, что она замкнутая на область видимости родителя (function Counter).

// Как это использовать? 
// Мы вызываем родительскую функцию и создается наш счетчик.
// Функция которую возвращает Counter, она сохраняется в переменную и она замкнутая на ту область видимости, которая возникла.
// */

// var oneCounter = Counter();

// /* 
// Теперь, когда мы вот эту вернувшуюся функцию будем вызывать много, много раз, она будет обращаться к той переменной, которая видна только ей и отдуда будет считывать значение и туда же его и записывать.
// */

// console.log(oneCounter());
// console.log(oneCounter());
// console.log(oneCounter());

// /* 
// При этом, если нам нужно будет создать еще один независимый счетчик, который будет независить от предыдущего, нам достаточно будет еще раз вызвать Counter() и мы получим новый счетчик.

// Каждый раз при вызовые Countera создается новая область видимости, в ней есть переменная count, но каждый раз она своя и каждый раз из них возвращаются новые функции, которые мы и сохраняем в переменную, а потом и вызываем неоднократно.

// Каждая из этих функций, она замкнута на совю область видимости и соответственно получает свой count, поэтому и счетчики независимы.
// */

// var secondCounter = Counter();
// var thirdCounter = Counter();

// console.log(secondCounter());
// console.log(thirdCounter());
// console.log(secondCounter());

// console.log(thirdCounter());
// console.log(secondCounter());
// console.log(thirdCounter());